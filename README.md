# CS18000-Group-Project


# Instructions on how to compile and run project
For Phase 1, we do not have a dedicated main method to show the interaction between the clients to the server to the databases. For Phase 2, we have a Server.java class that you can run once on your computer to start the server and interaction between clients. After running the Server class, you can run the Client.java class to run our fully functioning social media app in the console. If you want to simulate the social media app working on multiple devices, use IntelliJ’s Code with Me platform to share your workspace and allow every joined developer to run the Client in the terminal. For Phase 3, you can do the same as Phase 2 (just not the Code with Me part). You can simulate multiple clients by just running multiple Client.java scripts, such as one on IntelliJ and one executed in the terminal. Find all of our scripts in the src folder.


Here is some context to help you navigate the application:
- The application starts with a menu where you can either sign in or create a new account. When you first run the program, there is no data in the database, so make your own account and password. You can't make an account using an existing login username
- Once you sign in, you will have the option to either edit your profile, search for a user, or exit the program.
- If you’re editing your profile, you will be able to see your current profile name (defaulted to your login username), description, friends list, and blocked list. You will have the choice to edit your profile name or your description
- If you’re searching for another user, please search for their login username, as that is the name that would be constant throughout a user’s lifetime (profile name can change).
Once you search for a user, you will have a new menu with options; you will also be able to see their profile name, description, and friends list. You can either choose to add/remove them as a friend, add/remove them from your blocked list, directly message them, or go back. 
- If you choose to directly message them, the system will first load your message history with them before allowing you to type (note that to message them you and the receiver cannot be blocking each other). Type to your heart’s content. The receiver will know which messages are from you since it will be sent with your login username attached (the time is also included). The spacing of the chat messages resize as you type more messages; eventually you'll be able to use a scroll bar. On the far right side of each message, you can see either an "X" on windows or "..." on mac. That is your delete button. If you make a mistake, you can delete your message from the current chat and message history. You can only delete your own messages.
- To exit the chat, press the back button


There are no test cases written for our new classes that were created to build the client and server as all of those are IO functionality related. We also do not have test cases for any of the menu classes as those are JFrame and GUI related. We still have the previous test scripts though: UserTest.java, ProfileTest.java, DatabaseTest.java, ChatTest.java, and ChatDatabaseTest.java. Open the project on IntelliJ, install JUnit5 packages if prompted to, and press the run button at the top right corner (or F5) to run each test script.


# Brightspace and Vocareum Submission
Jason Chan submitted Phase 1 workspace to Vocareum<br>
Jason Chan submitted Phase 2 workspace to Vocareum<br>
Jason Chan submitted Phase 3 workspace to Vocareum


# Class Descriptions
## Chat
The chat class is used to simulate a chat between multiple users. It implements serializable which lets you save the state of chats between sessions. The class has two fields, id and messages. The id is used to get a unique chat between two users by concatenating the two usernames alphabetically in the constructor. Messages is an array list that contains the messages sent within the chat. The equals method is comparing the chat id to another object's chat id to see if they are representing the same chat. The id can be reproduced on either end of the client when they create a new Chat instance and pass in their username and then their receiver’s username. By being able to reproduce the id on both ends, we are able to get the same messages data for each client. The getID() method returns the id of the chat as a string. The getMessages() method returns the messages array list. The addMessage(String message) method allows users to add a message to the array list or chat. The removeMessage(int index) method allows users to remove/delete a message from the array list. The chat class is independent from other classes but it does interact with the ChatDatabase class. Instances of the class will later be created on the server. Our tests verify that the add and remove function correctly adds or removes a chat from the arraylist. We also verify that our constructor is correctly constructing the id to our intentions and that our equals method correctly identifies that. We simulated how the equals method would be used on the server by creating two Chat instances with the same usernames (but ordered differently) and making sure that they have the same id.


## ChatDatabase
The ChatDatabase class is a database containing chat objects. It’s used for loading and saving classes. The chat objects are stored with a chats.dat file. This class has one field, chats. Chats is a arrayList of type Chat    that holds all the chat objects. The constructor loads the chats from the chats.dat file and if a chat does not exist or an error occurs it will throw an exception to prevent the program from crashing. The method saveChat(Chat chat) updates a chat by rewriting the chats.dat file, re-adding all the chats in the file that doesn’t have the same id as variable chat but replacing the old chat with the same id with the updated chat. The addChat(Chat chat) method adds a new chat to the chats array list and appends it to the database. When the chat is successfully added to the database, a message saying “Chat has been registered” is printed as a confirmation. The chatRegistered(Chat chat) checks if a chat already exists within the chat list by comparing the existing chat ids with the id passed through the parameter. It returns true if the id exists and false if not. ChatDatabase interacts with Chat to save and get chat instances. It will later be requested by the server, first calling the chatRegistered, then addChat (if chat doesn’t exist), then saveChat method (whenever a client adds or deletes a message). The test for this class verifies that the database is properly writing to the chats.dat file and that we can retrieve and interpret that data. We do this by first creating a Chat instance with two usernames and populating it with random messages. We then save that chat to the database. To test if we can read the data, we create a new ChatDatabase object and a new Chat instance with the same usernames in a different order, to simulate how we would be writing this out on the server. We ensure that the chat already exists in the database and then make sure that that saved chat has the same messages that were initially stored.


## Profile
The profile class is used to create a profile for a user that contains their name, a description of them, their friend list, and their blocked list. The class has 4 fields: name, description, friends, and blockedUsers. The constructor initializes the String name, String description, the String array list friends, and the String array list blockedUsers. There are 4 getters which return name, description, friends, and blockedUsers, respectively.  There are two setters that allow setting a new name for the profile and a new description, setName(String name) and setDescription(String description) respectively. The addFriend(String username) adds a username to the friends list. The removeFriend(String username) method removes a username from the friends list. The addBlock(String username) adds the passed in username to the block list. The removeBlock(String username) removes the passed in username from the blocked list. There are 2 versions of the isFriend function, isFriend(Profile) and isFriend(User user), the difference is that one checks if the profiles friends contains the profile name from the profile passed while the one with the user as a variable passed checks for if the profiles friends contains the loginUsername. The same is the case for the isBlocked functions where there is isBlocked(Profile profile) which checks if the profile username is blocked, and the isBlocked(User user which checks for if the loginUsername is blocked). The profile class is a subclass of the User class and adds information on top of what is provided from the User class. Tests for this class consisted of ensuring that each fundamental method was correctly working as intended (i.e. friends were friends, blocked people were blocked, etc.). This class doesn’t have the methods to actually have one User friend another (that is in the Database class), but we can still populate Users with dummy friends to test.


## User
The user class is used to store basic information about a user and implements serializable to allow storage and retrieval of that data. The class has 3 fields: loginUsername, password, and profile. The constructor initializes a new instance of user with the passed in username, password, and profile. The class has 3 getters which return loginUsername, password, and profile respectively. The equalsUsername(User user) method compares two usernames to each other and returns true if they are equal and false if not. The equalsPassword(User user) method compares two passwords to each other and returns true if they are equal and false if not. The user class is the parent class of the profile class and has a reference to profile within it. The user class is related to the database class as the database class is where user objects are stored. Tests for this class consisted of creating dummy Users with different usernames and passwords and ensuring our equals methods were outputting the correct results based on the inputs.


## Database
The database class gives a way to store User objects which allows for loading, adding, and managing users. The class has one field, users, which is an array list of type User that stores all the user objects. The constructor initializes users and loads users from the users.dat file  using an ObjectInputStream. It reads this file until an EOF exception is caught at which point the program continues. The addUser(User user) method adds a user to the users array list and appends the new user to users.dat. The getUsers() method returns the users array list. The getUser(String username) retrieves the specified user from the users array list by searching using username, returns null if username isn’t found. The nameAlreadyExists(User user) method checks if a username already exists within the database by using equalsUsername method. The passwordAlreadyExists(User user) checks if a password already exists within the database by using the equalsPassword method. The friendUser(String username1, String username2) checks if the users are already friends with each other or if they have blocked each other. If neither of these conditions are true then the users become friends. The blockUser(String username1, String username2) checks if the users are already blocked and if they are friends with each other. If they are friends with each other it removes them as friends and adds them to the block list. This method returns if the user was just blocked or if they were blocked and unfriended. There is also the getUserFromProfile(Profile profile) which returns the user with the corresponding profile name. There is also a function called saveUsers() which rewrites all of the current users in the database to the output file. The database class is related to the user since it stores all of the user data within the users.dat file. Testing for this class ensured that the Database can retrieve information about saved Users properly. We did this by adding a User into the database, then creating a new Database to retrieve the stored information and check to make sure that stored User has the same username. Testing also included populating friends and blocks through the database, ensuring logins and passwords exist/match, and ensuring that blocking a friend unfriends the users.


## Server
The server class manages multiple clients, handles multi threading, and provides access to Database and ChatDatabase. It checks for connections of port 8080 and creates a new socket for each client. Each client gets its own clientHandler object that is stored within an arraylist. The server class has a couple static variables: clients (a list of Sockets), clientHandlers (a list of ClientHandler threads), DB (a Database class instance), CHAT_DB (a ChatDatabase class instance), serverSocket (a Server Socket reference). It has getters for some of the fields: getDatabase(), getChatDatabase(), and getClientHandlers(). We also have a public static void removeClient(ClientHandler sender, Socket client) that removes a client and its respective clientHandler when they exit the program properly or abruptly. The server class is related to the Database and ChatDatabase classes because it allows access to those databases.


## Client
Client class uses a socket to connect to a server. It lets the user sign in and communicate through the server. The run method is where the client connects to the server, the username and password are obtained, and allows for communication with the server. It begins by getting a socket connection to the server, then it initializes an input and output stream. The user is then prompted to login or create an account. The Client class also has the interactions for adding or removing friends, blocking or unblocking people, and messaging others. The client class is related to the server class and uses it to handle incoming messages from another client. The client class is also related to the User class since it uses the user’s credentials(username and password). The class is also connected to the ClientHandler class since an instance of ClientHandler is created to allow for multiple clients at once. It also is related to MessageOutputHandler for message handling. The client is what is executed to run the main application. Details of the main application and how to interact with it is in the compilation instructions.


## ClientHandler
The ClientHandler is responsible for managing each instance of Client. It uses the runnable interface to allow for handling each client in a separate thread. This class prompts for account sign in, account creation, searching for other users, messaging others, editing your own profile, blocking users, adding users as friends , removing friends, and unblocking users. It is related to the Database class since it accesses it to get the user information for the editing and the search. It also is related to the ChatDatabase class because it uses that to store the messaging history.


## MessageOutputHandler
MessageOutputHandler is used to handle incoming messages. It uses runnable to run everything in a separate thread. It uses a bufferedReader to read the incoming messages. When run, it goes into an infinite loop that will read messages using the bufferedreader. The loop will stop when the command /bye is input, all other inputs will be printed to the console.


# IO Testing
Extensive testing was commenced to ensure that the social media console application is fully functioning, bug free, and working as it is currently intended. In the sign in menu, we made sure to test to make sure the server denies creation of already existing usernames and deny incorrect username or password during sign-ins. We made sure to run around the program, visiting different menus in different orders to make sure that the menu flow is working as intended and nothing breaks. We made sure that, when editing the profile name or description, other users can immediately see the changes if they research the same username. We ensured that the adding/removing of friends and blocked users works as intended and the information is shared immediately with other clients. While doing all of this, we also made sure to rerun the server so that we know that the database is correctly retrieving all the information stored through the .dat files. We also make sure to handle all errors that could occur when the client abruptly leaves and closes the program. We don’t want the server to throw an error and cause problems for others because of that (even though it probably won’t because everything is on separate threads). We made sure to also extensively test the messaging system. Two clients can send messages to each other with ease. Some current caveats have already been listed in the compilation section. If one client leaves, the other client can still keep sending messages and when the other user comes back the message history will be updated so he will see all of the new messages that he didn’t read while he was gone. Deleting and exiting in the console specific way also works perfectly.


# SignInMenu
It is the first menu that the user is greeted with. It has two buttons: "Sign In" and "Sign Up". The first button "Sign In" will the integer output to 1 and the second "Sign Up" will set the integer to 2. The number of the integer could be obtained through the getOutput() method which is called in the client to receive what the user inputted. The client will act accordingly and will either create a new account if the user chooses to sign up or look for an existing account.


# LogInMenu
It is the second menu that appears after the user has chosen the option to sign in or sign up. The button signinbutton or signupbutton and prompt on the menu changes depending on if the user chose to sign in or sign up. The login information is entered by the user into the text fields and stored in the String variables username and password. They could be retrieved by the client by calling the methods getUsername() and getPassword().


# MainMenu
The main menu is the menu where after the user logs in where they choose their action. It is the default menu that the user will return to after they have performed an action int he client. It has three buttons, the editButton, searchButton, and exitButton. The editButton will lead the user to the menu where they edit and their own username and description. The searchButton will lead the user to the menu where they search for other users. The exitButton will lead the user to exit the program. The buttons store int values to record the user's response in menuResponse, which could be retrieved by the client through getMenuResponse().


# NameDescChangeMenu
The menu has textfields where the user could change their name or description. The new name or description is stored in the String message when pressing the sendButton button. The getMessage() method is called by the client to receive the new name or description.


# SearchUserMenu
The menu is where the user searches for users and decides what to do with them. The menu initially displays only the textfield for searching the user with and the search button. Upon entering the name and pressing the search button, the username is stored in string searchedUser and could be called by the client through getSearchedUser. There are two possibilities after searching, where the user does not exist or exists. If the user does not exist the client calls the method displayUserNotFound(), which shows an error message that informs the user the user they searched for does not exist. If the user exists, the client calls the method userActionMenu(), which displays additional buttons that prompts the user to either add/remove friend, block/unblock the user, or message the user they searched for. The actionPerformed() method records the user's actions if any of these buttons are pressed and stores it as an int value in menuResponse. The menuResponse could be retrieved by the client through the method getMenuResponse();


# ChatMenu
The ChatMenu is the menu where someone messages another user. The menu has a textfield for entering a message, and a textarea for showing sent messages. It also has the send button which places a message from the textfield into the textarea in actionPerformed(). The method addMessage() could be called by the client to fill the textarea with records of messages from its database and is immediately called after the client creates a new ChatMenu instance.


# ChangeNameDescriptionMenu
This is the menu where the user makes the choice to change their name or their description when choosing to change their name or description from the MainMenu. It has an int menuResponse and two buttons nameButton and descButton. The actionPerformed() method takes which button the user presses and assigns a number to menuResponse depending on which button is pressed. 1 if nameButton is pressed and 2 if descButton is pressed. The menuResponse could be retrieved by the client by the method getMenuResponse().


# AddRemoveFriendButton
This is the method where the user chooses if they want to add or remove a friend following choosing the add or remove friend option from the SearchUserMenu. It has two buttons removeButton and addButton. Method actionPerformed assigns the menuResponse of an int value 1 or 2 depending on the button pressed and the menuResponse value could be retrieved by the client by calling getMenuResponse().


# AddRemoveBlockedMenu
The menu where the user chooses to add or remove a blocked user after choosing the option to block or unblock a user from the SearchUserMenu. It has two buttons, removeButton and addButton that will assign the values 2 and 1 to menuResponse in actionPerformed respectively. menuResponse is retrieved by the client with the method getMenuResponse.

